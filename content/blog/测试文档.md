---
title: "测试文档"
author: [kunduin]
date: "2018-03-04"
---

# 测试文档


### v2.0.0 正式版

#### 软工小组第二组
---

### 更新历史

| 日期     | 更新者   | 更新内容                            | 版本号               |
| -------- | -------- | ----------------------------------- | -------------------- |
| 17/10/10 | 全体成员 | 功能测试用例集                      | 参见需求规格说明文档 |
| 17/11/25 | 全体成员 | 集成测试                            | v1.0.1               |
| 17/12/31 | 温曜铭   | 数据层单元测试                      | v1.0.2               |
| 18/01/03 | 徐翔哲   | 更难的数据层单元测试+销售单单元测试 | v1.0.3               |
| 18/01/08 | 吴新宇   | 逻辑层报溢报损单测试                | v1.0.4               |
| 18/01/12|全体成员|整合了测试报告和测试用例，汇总了测试结果|v2.0.0

--

## 目录

- [1. 功能测试用例集](#1-功能测试用例集)
- [2. 集成测试](#2-集成测试)
    - [2.1 测试内容简述](#21-测试内容简述)
    - [2.2 测试结果简述](#22-测试结果简述)
- [3. 单元测试](#3-单元测试)
    - [3.1 数据层](#31-数据层)
    - [3.2 逻辑层](#32-逻辑层)
- [4. 系统运行测试](#4-系统运行测试)










## 1. 功能测试用例集

这部分内容请参见《需求规格说明文档》，所有的功能测试用例集均已在系统中实现

## 2. 集成测试

### 2.1 测试内容简述
在集成测试阶段，我们小组为每一个层间接口建立了相应的stub，并且由于逻辑层的逻辑对象具有较高的复杂性，我们为每一个模块的主要逻辑对象也建立了stub。我们集成测试的方法是，写好所有的stub（上层的stub其实起到了driver的作用来调用下层的stub），然后使用gradle来构建整个项目，如果编译不报错，则说明构建正确。

理论上说，集成测试应当是测试系统各个模块之间的协作是否正确，并在开发的过程中逐渐替代stub，直到最终构建成功。但是我们小组在之前的体系结构设计过程中经历过四次重构，并对体系结构中的细节做了较为深入的探讨，甚至通过先写出某一用例（销售单）的demo来明确设计的意图。因此，我们的集成测试主要面向的问题是，在构造的过程中是否有笔误（比如写错返回值，少写接口）。如果通过集成测试可以保证框架代码与文档一致，则可以很大程度上确保项目架构没问题。因此，在权衡了时间开销与效益之后，我们没有选择持续集成的方式，而是选择了手动构建的方式少量进行集成测试来排除错误。

### 2.2 测试结果简述
第一次集成测试失败了，主要报错出现在单据的ID应当是`String`类型，而商品、客户等实体的ID应当是`int`类型，我们用了一天左右的时间确定了这个规则并从界面到数据层更正了过来。

第二次集成测试成功通过。

## 3. 单元测试

我们的实现有这样的特点：**层间实现差别较大，层内实现相似度高**。为了不影响可修改性，我们没有过度复用相似的代码，而是选择了以相似的框架来实现不同的内容（这样做还有一个好处，就是debug的时候可以轻松发现同类缺陷）
但是，为了使写界面的同学也能拥有丰富的编码体验，逻辑层中选取了一个较为简单的模块交由他实现，因此这个模块与别的模块实现差别较大，需要单独测试。

基于上述情况，我们这样安排了测试：
- 对于数据层实体（商品，商品分类，客户，用户，银行账户）进行较为全面的测试，因为这几个实体是各个功能正确实现的前提。
- 对于数据层单据，我们选取销售单进行了较为全面的测试，因为各单据DAO的实现类似，而销售单涉及到的关联（外键）最多，规则也最复杂，我们有理由相信，通过测试的销售单DAO意味着其它单据的DAO也没有逻辑错误了（如果有缺少字段这样的错误，在后来的整体功能测试中更容易发现并且消除难度不太大）（事实上后来确实如此）
- 对于逻辑层实体，我们选取了商品进行代表性测试，同时选取了“获取商品分类”这个方法进行测试，因为获取商品分类中涉及递归查找，是一个较为复杂的算法。
- 对于逻辑层单据，我们选取了销售单和收款单进行代表性测试，因为销售单字段复杂，审批通过的触发条件多，容易产生各种错误；收款单字段最少，在一开始的时候容易测试。
- 对于逻辑层单据，交给界面层同学的部分有单独的测试，因为实现思路不同，销售单的测试不能代表这部分正确。
- 对于逻辑层的“促销策略”功能，我们设置了“增加”和“查找”这两个测试，因为促销策略中用到了较为复杂的设计模式。
- 对于启动模块和其它多线程运行模块（比如定时保存&清空的单据编号生成器）我们也安排了相应的用例。

### 3.1 数据层

#### 3.1.1 user

##### AuthorizationControllerImplModifiedTest

- 正常添加一个用户，所有的字段都被填写了
    - 通过
- 添加一个仅包括id的空用户
    - 通过
- find方法传入null可以查到所有字段
    - 通过
- update方法，尝试更新各个字段
    - 通过
- update2，测试缓存是否进行深拷贝
    - 通过
- delete方法，删除一个用户
    - 通过

---

##### AuthorizationControllerImplTest

>这部分测试测试的是不带缓存的版本，为早期测试，参见代码

##### AuthorizationControllerImplTestLevel2

>同上，但是难度更大，主要包括了一些空值的测试

##### AuthorizationControllerImplTestLevel3

>同上，对一些异常的抛出进行了测试

##### AuthorizationControllerImplTestLevel4

>同上，对对特殊值、边界情况进行了进一步测试

##### UserDAOTest

- add 对UserDAO的第一次测试，仅测试是否能正确与数据库通信
    - 通过

##### UserDAOTestTemp

- add 在某一次运行测试中发现的特殊值产生的错误，离开当时的特殊条件已没有意义


---
---
---

#### 3.1.2 bankAccount

##### BankAccountControllerImplTest1

> 早期的无缓存测试，参见代码

##### BankAccountControllerImplTest2

> 同上，增加了一些对空值的判断


---
---
---

#### 3.1.3 client

##### ClientControllerImplTest1

> 早期的无缓存测试，参见代码

---
---
---

#### 3.1.4 commodity( and category)

##### CommodityCategoryControllerImplModifiedTest

- 这个类下所有的测试均已通过，参见代码注释头，这个类是对商品分类较为全面的测试

##### CommodityCategoryControllerImplTest

- 这个类是最开始对商品分类嵌套添加&查找功能的测试，在最开始失败了，之后建立了缓存，丢弃了这个类

##### CommodityCategoryControllerImplTestTemp

- 这个类是简化版的上一类测试，这个测试通过了。（其实就是上一个测试注释掉一部分）

##### CommodityCategoryDAOTest

- 对商品分类DAO的首次添加测试

##### CommodityControllerImplModifiedTest

- 对商品的带缓存的较为完整的测试，其中update2没有通过测试，是数据层在写的过程中有一个不可更新字段并未向逻辑层核实，之后已经统一为不可修改，放弃此用例

##### CommodityControllerImplTest

- 对商品的较为完整的测试，都是最简单的情况

##### CommodityControllerImplTestLevel1

- 对商品的较难的测试，包括一些空值，其中test4因为用例出错被去掉了

##### CommodityControllerImplTestLevel2

- 上一组用例是对空值的测试，而这一组用例是对空指针的测试，已全部通过

##### CommodityControllerImplTestLevel3

- 对抛出异常的测试，已通过

##### CommodityControllerImplTestLevel4

- 对于特殊值和sql注入攻击的测试，已通过

##### CommodityUpdateTest_realCase

- 对一个特殊值的测试，现在已失效

#### 3.1.5 money receipt

##### CollectionControllerImplTest

- 对收款单的测试，其中测试3和4失败了，原因为后期bankAccountDAO已修改为缓存版本，而4的用例有浮点数格式问题。

##### PaymentControllerImplTest

- 对付款单的测试，结果和错误原因同上

#### 3.1.6 sale receipt

##### SaleControllerImplTest

- 对销售单的测试，其中测试3-1失败了，原因是浮点数格式

##### SaleReturnControllerImplTest

- 对销售退货单的测试，结果与原因同上

### 3.2 逻辑层

#### 3.2.1 commodity( and category)

##### CommodityCategoryServiceImplTest

- 对商品分类递归查找的测试，已通过

##### CommodityServiceImplTest

- 对商品service的基本测试，开始本测试全部失败，修改之后由于时间原因直接进行整体测试，未发现类似缺陷

#### 3.2.2 overflow

##### OverflowServiceImplTest

- 逻辑层这个部分是界面层同学进行编程体验的部分，模块本身也较为简单，因此主要进行了基础功能测试

#### 3.2.3 sale

##### SaleServiceImplTest

- 对销售service各项功能的全面测试，已通过

#### 3.2.4 user

##### UserServiceImplTestOutDated

- 对用户service的早期的基础测试，全部通过

#### 3.2.5 promotion

##### PromotionServiceImplTest

- 对促销service的添加和查找的测试，添加方法最开始失败了，因为测试之前应该先开启线程

#### 3.2.6 counterTest

- 对单据编号计数器的测试，这个测试只是为了保证多线程程序可以正常运行、保存，并没有明确的“预期输出”

#### 3.2.7 SMainTest

- 算是最开始的集成测试，编译成功即可通过


## 4. 系统运行测试

这部分测试是在发布前以及增加功能后对系统的直接测试，好处是测试效率较高，（比如一次提交可以测试某一单据的所有字段）。并且测试更有针对性，比如有些交给界面防御的输入检查，没有必要一一在后端反复测试。下面列举几个关键用例。

### 4.1 商品管理
- 通过测试：
    - 增加商品后填写各个字段，提交后商品分类中应该出现刚才添加的商品，并且应该有自动生成的ID
    - 增加商品后删除商品，应该可以正常删除（因为没有发生交互）
    - 右键点击有子分类的商品分类，应该只能添加分类；右键点击有子商品的分类，应该只能添加商品。

### 4.2 客户管理
- 通过测试：
    - 增加客户后填写各个字段系统应当生成新客户，并返回自动生成的客户ID。
    - 增加客户后删除，应该可以正常删除。
    - 修改客户信息，不允许修改应付应收.

### 4.3 银行账户管理
- 通过测试：
    - 增加银行账户，可以由用户自己指定银行账户ID
    - 删除银行账户，可以正常删除
- 未通过测试：
    - 修改银行账户，不允许修改ID或余额（其实就是银行账户不能修改）
        - 错误：修改了账户的ID

### 4.4 销售单
- 通过测试：
    - 增加销售单，填写部分字段，然后退出，系统提示是否保存，如果选择保存则暂存单据。暂存单据时字段均不会报错。
    - 打开草稿单，填写部分字段，然后提交，系统提示客户未填写。
    - 填写完整后选择提交，提交后提示success

### 4.5 审批单据
- 通过测试：
    - 审批一张单据，系统对单据生效，如果不能生效，则提示错误原因。
    - 批量审批，系统对单据批量生效&失效。
    - 审批不通过一张单据，系统使单据不生效。
    - 编辑并审批通过一张单据，系统生效修改后的单据。

### 4.6 红冲单据
- 通过测试：
    - 红冲一张单据，系统将单据取反并生效
    - 红冲并复制（修改）一张单据并提交，系统先红冲，然后将单据取反并交由用户编辑

### 4.7 权限检查
- 通过测试：
    - 普通财务人员查找银行账户，提示无权限
    - 最高权限财务人员查找银行账户，正常查看


